This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-10T19:42:22.667Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
include/
  constants/
    fieldConstants.hpp
  core/
    subsystem.hpp
  display/
    robot_display.hpp
  movement/
    chassis.hpp
    control_system.hpp
    driver_control.hpp
  subsystems/
    clamp.hpp
  api.h
  main.h
  robot_state.hpp
src/
  control_system_impl.cpp
  main.cpp
  movement_impl.cpp
.gitignore
.repomixignore
Makefile
repomix.config.json
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="include/constants/fieldConstants.hpp">
// Field_Constants.hpp
#pragma once
#include "main.h"
#include <vector>

namespace field {

// Field dimensions (inches) - verified from page A-1
const double FIELD_WIDTH = 144.0;
const double FIELD_HEIGHT = 144.0;

// Base coordinate structures
struct Point {
    double x;
    double y;
    Point(double x, double y) : x(x), y(y) {}
};

struct FieldElement {
    Point position;
    double height;
    FieldElement(double x, double y, double h = 0) : position(x, y), height(h) {}
};

// Ladder Constants - verified from pages A-10 to A-12
namespace ladder {
    const FieldElement CENTER(72, 72, 0);
    const double BASE_WIDTH = 36.0;
    const double BASE_HEIGHT = 36.0;
    
    // Exact height levels
    const double LEVEL_1_HEIGHT = 18.16;
    const double LEVEL_2_HEIGHT = 32.16;
    const double LEVEL_3_HEIGHT = 46.16;
    const FieldElement HIGH_STAKE(72, 72, 46.16);
}

// Wall Stakes - ½" Schedule 40 PVC
namespace stakes {
    const double STAKE_HEIGHT = 14.5; // Height verification pending
    const FieldElement RED_ALLIANCE(72, 0, STAKE_HEIGHT);
    const FieldElement BLUE_ALLIANCE(72, 144, STAKE_HEIGHT);
    const FieldElement LEFT_NEUTRAL(0, 72, STAKE_HEIGHT);
    const FieldElement RIGHT_NEUTRAL(144, 72, STAKE_HEIGHT);
}

// Corners - verified 12"x12" triangular sections
namespace corners {
    struct Corner {
        Point position;
        bool isPositive;
        double size;
        Corner(double x, double y, bool pos) : 
            position(x, y), isPositive(pos), size(12.0) {}
    };

    const Corner BOTTOM_LEFT(0, 0, false);    // Negative
    const Corner BOTTOM_RIGHT(144, 0, true);  // Positive
    const Corner TOP_LEFT(0, 144, true);      // Positive
    const Corner TOP_RIGHT(144, 144, false);  // Negative
}

// Mobile Goals
namespace mobile_goals {
    const double GOAL_HEIGHT = 14.5;
    const double GOAL_DIAMETER = 10.0;
    
    // Starting positions pending final field specs
    const FieldElement BOTTOM_LEFT(36, 36, GOAL_HEIGHT);
    const FieldElement BOTTOM_RIGHT(108, 36, GOAL_HEIGHT);
    const FieldElement CENTER(72, 72, GOAL_HEIGHT);
    const FieldElement TOP_LEFT(36, 108, GOAL_HEIGHT);
    const FieldElement TOP_RIGHT(108, 108, GOAL_HEIGHT);
}

// Autonomous Line - positions to be verified with final specs
namespace auto_line {
    const double LOWER_Y = 60.0;
    const double UPPER_Y = 84.0;
}

// Starting Areas - defined as ranges along starting lines
namespace start_zones {
    struct StartZone {
        double y_pos;      // Y coordinate of starting line
        double x_min;      // Minimum legal X coordinate
        double x_max;      // Maximum legal X coordinate
    };
    
    const StartZone RED_ZONE = {18.0, 0.0, 144.0};
    const StartZone BLUE_ZONE = {126.0, 0.0, 144.0};
}

// Ring specifications
namespace rings {
    const double OUTER_DIAMETER = 7.0;
    const double INNER_DIAMETER = 3.0;
    const double THICKNESS = 2.0;
    
    // Starting positions pending final field specs
    // Each position represents bottom ring of a stack
    // Note: Some stacks flipped per Sept 3 update
    struct RingStack {
        Point position;
        int count;
        bool flipped;
        RingStack(double x, double y, int c, bool f) : 
            position(x, y), count(c), flipped(f) {}
    };

    // Ring stack positions to be updated when final specs released
    const std::vector<RingStack> RED_STACKS = {
        // Bottom row examples (to be verified)
        RingStack(24, 24, 4, false),
        RingStack(48, 24, 4, true),
        // Add remaining positions when verified
    };

    const std::vector<RingStack> BLUE_STACKS = {
        // To be populated with verified positions
    };
}

} // namespace field
</file>

<file path="include/core/subsystem.hpp">
#pragma once
#include <memory>
#include <string>
#include <unordered_map>
#include <functional>
#include <typeindex>
#include <any>

namespace core {

// Base interface for all subsystems
class ISubsystem {
public:
    virtual ~ISubsystem() = default;
    virtual void initialize() = 0;
    virtual void update() = 0;
    virtual void disable() = 0;
    virtual bool isEnabled() const = 0;
    virtual const std::string& getName() const = 0;
};

// Configuration base class
class SubsystemConfig {
public:
    virtual ~SubsystemConfig() = default;
    bool dev_mode = false;
};

// Base class for subsystems with common functionality
template<typename Config = SubsystemConfig>
class Subsystem : public ISubsystem {
protected:
    std::string name_;
    bool enabled_ = false;
    Config config_;

public:
    Subsystem(const std::string& name, const Config& config = Config())
        : name_(name), config_(config) {}

    virtual void initialize() override { enabled_ = true; }
    virtual void disable() override { enabled_ = false; }
    virtual bool isEnabled() const override { return enabled_; }
    virtual const std::string& getName() const override { return name_; }
    
    const Config& getConfig() const { return config_; }
};

// Registry for managing subsystems
class SubsystemRegistry {
private:
    static SubsystemRegistry* instance_;
    std::unordered_map<std::string, std::shared_ptr<ISubsystem>> subsystems_;
    std::unordered_map<std::type_index, std::any> type_cache_;

    SubsystemRegistry() = default;

public:
    static SubsystemRegistry& getInstance() {
        if (!instance_) {
            instance_ = new SubsystemRegistry();
        }
        return *instance_;
    }

    template<typename T>
    void registerSubsystem(const std::shared_ptr<T>& subsystem) {
        auto name = subsystem->getName();
        subsystems_[name] = subsystem;
        type_cache_[std::type_index(typeid(T))] = subsystem;
        subsystem->initialize();
    }

    template<typename T>
    std::shared_ptr<T> getSubsystem(const std::string& name) {
        auto it = subsystems_.find(name);
        if (it != subsystems_.end()) {
            return std::dynamic_pointer_cast<T>(it->second);
        }
        return nullptr;
    }

    template<typename T>
    std::shared_ptr<T> getSubsystemByType() {
        auto it = type_cache_.find(std::type_index(typeid(T)));
        if (it != type_cache_.end()) {
            return std::any_cast<std::shared_ptr<T>>(it->second);
        }
        return nullptr;
    }

    void updateAll() {
        for (auto& [name, subsystem] : subsystems_) {
            if (subsystem->isEnabled()) {
                subsystem->update();
            }
        }
    }

    void disableAll() {
        for (auto& [name, subsystem] : subsystems_) {
            subsystem->disable();
        }
    }
};

// Event system for inter-subsystem communication
class EventSystem {
private:
    static EventSystem* instance_;
    std::unordered_map<std::string, std::vector<std::function<void(const std::any&)>>> handlers_;

    EventSystem() = default;

public:
    static EventSystem& getInstance() {
        if (!instance_) {
            instance_ = new EventSystem();
        }
        return *instance_;
    }

    template<typename T>
    void subscribe(const std::string& event_type, std::function<void(const T&)> handler) {
        handlers_[event_type].push_back(
            [handler](const std::any& data) {
                if (auto* typed_data = std::any_cast<T>(&data)) {
                    handler(*typed_data);
                }
            }
        );
    }

    template<typename T>
    void emit(const std::string& event_type, const T& data) {
        auto it = handlers_.find(event_type);
        if (it != handlers_.end()) {
            for (const auto& handler : it->second) {
                handler(data);
            }
        }
    }
};

} // namespace core
</file>

<file path="include/display/robot_display.hpp">
#pragma once
#include "main.h"
#include "robot_state.hpp"
#include "pros/llemu.hpp"
#include <string>
#include <functional>

namespace display {

class RobotDisplay {
private:
    RobotState& robot_;
    bool initialized_ = false;

    void updateStatus() {
        if (!initialized_) return;

        // Update clamp status
        std::string clamp_status = "Clamp: ";
        clamp_status += robot_.getClamp().isClamped() ? "ENGAGED" : "RELEASED";
        pros::lcd::set_text(1, clamp_status);

        // Update motor status
        std::string motor_text = "Motors: ";
        auto& chassis = robot_.getChassis();
        for (int i = 0; i < chassis.getMotorCount(); i++) {
            const auto& motor = chassis.getMotor(i);
            motor_text += "M" + std::to_string(i+1) + ":" + 
                         std::to_string(static_cast<int>(motor.get_actual_velocity())) + " ";
        }
        pros::lcd::set_text(2, motor_text);

        // Update mode status
        std::string mode_text = robot_.isDevMode() ? "DEV MODE" : "COMP MODE";
        pros::lcd::set_text(3, mode_text);

        // Check button presses manually
        if (pros::lcd::read_buttons() & LCD_BTN_LEFT) {
            robot_.getClamp().toggle();
            pros::delay(200); // Debounce
        }
        if (pros::lcd::read_buttons() & LCD_BTN_CENTER) {
            robot_.reset();
            pros::delay(200); // Debounce
        }
    }

public:
    RobotDisplay(RobotState& robot) : robot_(robot) {
        // Initialize LCD
        pros::lcd::initialize();
        initialized_ = true;

        // Display initial interface
        pros::lcd::set_text(0, "== Robot Control ==");
        pros::lcd::set_text(4, "L:Clamp C:Reset");
    }

    void update() {
        updateStatus();
    }

    void setStatusMessage(const std::string& msg) {
        if (initialized_) {
            pros::lcd::set_text(5, msg);
        }
    }
};

} // namespace display
</file>

<file path="include/movement/chassis.hpp">
#pragma once
#include "main.h"
#include "constants/fieldConstants.hpp"
#include "pros/motors.hpp"
#include "pros/imu.hpp"
#include "pros/rotation.hpp"
#include "core/subsystem.hpp"
#include <memory>
#include <vector>

namespace movement {

// Forward declarations
template<typename Config>
class Chassis;

// Configuration options
enum class DriveType {
    TANK,
    HOLONOMIC,
    MECANUM
};

enum class OdomType {
    NONE,           // Dead reckoning only
    TRACKING,       // Tracking wheels
    INTEGRATED,     // Integrated encoders
    IMU_ENHANCED    // IMU-enhanced tracking
};

// Base configuration struct
template<DriveType DT, OdomType OT>
struct ChassisConfig {
    static constexpr DriveType driveType = DT;
    static constexpr OdomType odomType = OT;
};

// Position tracking class
class Position {
public:
    double x;
    double y;
    double heading; // Radians

    Position(double x = 0, double y = 0, double heading = 0)
        : x(x), y(y), heading(heading) {}

    double distanceTo(const field::Point& target) const {
        double dx = target.x - x;
        double dy = target.y - y;
        return std::sqrt(dx*dx + dy*dy);
    }

    double angleTo(const field::Point& target) const {
        return std::atan2(target.y - y, target.x - x);
    }
};

// Base chassis interface
template<typename Config>
class Chassis : public core::ISubsystem {
protected:
    std::string name_;
    mutable Position current_pos_;
    std::vector<pros::Motor> motors_;
    std::unique_ptr<pros::IMU> imu_;  // Added IMU member here
    bool enabled_ = false;

public:
    explicit Chassis(const std::string& name = "chassis") 
        : name_(name), current_pos_(), motors_(), imu_(nullptr) {}  // Initialize imu_ in constructor

    virtual ~Chassis() override = default;

    // ISubsystem interface implementation
    virtual void initialize() override { enabled_ = true; }
    virtual void update() override {}
    virtual void disable() override { 
        enabled_ = false;
        stop(); 
    }
    virtual bool isEnabled() const override { return enabled_; }
    virtual const std::string& getName() const override { return name_; }

    virtual void initializeSensors(int imu_port) {
        if constexpr (Config::odomType == OdomType::IMU_ENHANCED) {
            imu_ = std::make_unique<pros::IMU>(imu_port);
            if (imu_) {
                imu_->reset();
                pros::delay(2000); // Wait for IMU calibration
            }
        }
    }

    // Motor management
    virtual void addMotor(int port, bool reversed = false) {
        if (motors_.size() < 10) {
            pros::Motor motor(port); // Create motor with just the port
            if (reversed) {
                motor.set_reversed(true); // Set reversed state after creation
            }
            motors_.push_back(motor);
        }
    }

    // Direct motor control
    virtual void setMotorVelocity(int index, double velocity) {
        if (index >= 0 && index < static_cast<int>(motors_.size())) {
            motors_[index].move_velocity(velocity);
        }
    }

    // Required movement interface
    virtual void moveTo(const field::Point& target, bool reverse = false) = 0;
    virtual void turnTo(double angle) = 0;
    virtual void stop() {
        for (auto& motor : motors_) {
            motor.move_velocity(0);
        }
    }

    // Position tracking
    virtual Position getPosition() const { return current_pos_; }

    // Accessors
    size_t getMotorCount() const { return motors_.size(); }
    const pros::Motor& getMotor(int index) const { 
        return motors_.at(index); // Using at() for bounds checking
    }
};

// Tank drive specialization
template<OdomType OT>
class Chassis<ChassisConfig<DriveType::TANK, OT>> : public Chassis<void> {
private:
    std::unique_ptr<pros::IMU> imu_;
    std::unique_ptr<pros::Rotation> left_encoder_;
    std::unique_ptr<pros::Rotation> right_encoder_;
    
    // PID constants
    static constexpr double kP = 0.8;
    static constexpr double kI = 0.001;
    static constexpr double kD = 0.2;
    static constexpr double kTurnP = 1.2;

public:
    explicit Chassis(const std::string& name = "tank_chassis") 
        : Chassis<void>(name) {}

    void initializeSensors(int imu_port, int left_enc_port = -1, int right_enc_port = -1) {
        if constexpr (OT == OdomType::IMU_ENHANCED || OT == OdomType::TRACKING) {
            imu_ = std::make_unique<pros::IMU>(imu_port);
            imu_->reset();
            pros::delay(2000); // Wait for IMU calibration
        }
        
        if constexpr (OT == OdomType::TRACKING) {
            if (left_enc_port != -1) {
                left_encoder_ = std::make_unique<pros::Rotation>(left_enc_port);
                left_encoder_->reset_position();
            }
            if (right_enc_port != -1) {
                right_encoder_ = std::make_unique<pros::Rotation>(right_enc_port);
                right_encoder_->reset_position();
            }
        }
    }

    void moveTo(const field::Point& target, bool reverse = false) override {
        if (!enabled_) return;

        while (enabled_) {
            Position current = getPosition();
            double distance = current.distanceTo(target);
            
            if (distance < 1.0) break; // 1 inch tolerance
            
            double angle_error = current.angleTo(target) - current.heading;
            if (reverse) angle_error += M_PI;
            
            // Normalize angle error
            while (angle_error > M_PI) angle_error -= 2*M_PI;
            while (angle_error < -M_PI) angle_error += 2*M_PI;
            
            // Calculate motor powers using PID
            double turn_power = kTurnP * angle_error;
            double drive_power = kP * distance;
            
            // Apply powers to motors
            for (size_t i = 0; i < motors_.size(); i++) {
                bool is_left = i < motors_.size()/2;
                double power = drive_power + (is_left ? turn_power : -turn_power);
                motors_[i].move_velocity(power * 200); // Scale to velocity
            }
            
            pros::delay(10);
        }
        
        stop();
    }

    void turnTo(double angle) override {
        if (!enabled_) return;

        while (enabled_) {
            double current = getPosition().heading;
            double error = angle - current;
            
            // Normalize error
            while (error > M_PI) error -= 2*M_PI;
            while (error < -M_PI) error += 2*M_PI;
            
            if (std::abs(error) < 0.05) break; // ~3 degree tolerance
            
            double power = kTurnP * error;
            
            // Apply powers to motors
            for (size_t i = 0; i < motors_.size(); i++) {
                bool is_left = i < motors_.size()/2;
                motors_[i].move_velocity((is_left ? power : -power) * 200);
            }
            
            pros::delay(10);
        }
        
        stop();
    }

    Position getPosition() const override {
        if constexpr (OT == OdomType::IMU_ENHANCED) {
            if (imu_) {
                double heading = imu_->get_heading() * M_PI / 180.0;
                return Position(current_pos_.x, current_pos_.y, heading);
            }
        }
        else if constexpr (OT == OdomType::TRACKING) {
            if (imu_ && left_encoder_ && right_encoder_) {
                double left_dist = left_encoder_->get_position() / 360.0 * (2.75 * M_PI);
                double right_dist = right_encoder_->get_position() / 360.0 * (2.75 * M_PI);
                double heading = imu_->get_heading() * M_PI / 180.0;
                
                double distance = (left_dist + right_dist) / 2.0;
                double new_x = current_pos_.x + distance * std::cos(heading);
                double new_y = current_pos_.y + distance * std::sin(heading);
                
                current_pos_.x = new_x;
                current_pos_.y = new_y;
                current_pos_.heading = heading;
            }
        }
        return current_pos_;
    }
};

} // namespace movement
</file>

<file path="include/movement/control_system.hpp">
#pragma once
#include "main.h"
#include "movement/chassis.hpp"
#include "movement/driver_control.hpp"
#include "pros/misc.hpp"
#include "core/subsystem.hpp"
#include <functional>
#include <string>
#include <unordered_map>
#include <vector>
#include <memory>
#include <chrono>
#include <algorithm>

namespace movement {

// Forward declarations
template<typename ChassisConfig>
class MacroSystem;

template<typename ChassisConfig>
class InputMapper;

// Base macro interface
class Macro {
public:
    virtual ~Macro() = default;
    virtual void execute() = 0;
    virtual bool isComplete() const = 0;
    virtual void reset() = 0;
};

// Input binding types
enum class InputType {
    BUTTON,
    BUTTON_COMBO,
    ANALOG_ABOVE,
    ANALOG_BELOW,
    SEQUENCE
};

// Input binding structure
struct InputBinding {
    InputType type;
    std::vector<pros::controller_digital_e_t> buttons;
    pros::controller_analog_e_t analog = ANALOG_LEFT_Y;
    double threshold = 0.0;
    std::chrono::milliseconds sequence_window{500};
};

// Input mapper class
template<typename ChassisConfig>
class InputMapper : public core::ISubsystem {
private:
    std::string name_;
    pros::Controller& controller_;
    std::unordered_map<std::string, InputBinding> bindings_;
    std::unordered_map<std::string, std::function<void()>> actions_;
    std::vector<std::pair<std::chrono::steady_clock::time_point, std::string>> input_history_;
    bool enabled_ = false;
    
    bool checkBinding(const InputBinding& binding) {
        switch (binding.type) {
            case InputType::BUTTON:
                return !binding.buttons.empty() && 
                       controller_.get_digital(binding.buttons[0]);
                
            case InputType::BUTTON_COMBO: {
                return std::all_of(binding.buttons.begin(), binding.buttons.end(),
                    [this](auto btn) { return controller_.get_digital(btn); });
            }
            
            case InputType::ANALOG_ABOVE:
                return (controller_.get_analog(binding.analog) / 127.0) > binding.threshold;
                
            case InputType::ANALOG_BELOW:
                return (controller_.get_analog(binding.analog) / 127.0) < binding.threshold;
                
            case InputType::SEQUENCE: {
                auto now = std::chrono::steady_clock::now();
                
                // Clean old inputs
                input_history_.erase(
                    std::remove_if(input_history_.begin(), input_history_.end(),
                        [&](const auto& entry) {
                            return now - entry.first > binding.sequence_window;
                        }),
                    input_history_.end()
                );

                // Check sequence
                if (input_history_.size() == binding.buttons.size()) {
                    bool matches = true;
                    for (size_t i = 0; i < binding.buttons.size(); i++) {
                        if (controller_.get_digital(binding.buttons[i]) != 
                            controller_.get_digital(binding.buttons[i])) {
                            matches = false;
                            break;
                        }
                    }
                    if (matches) {
                        input_history_.clear();
                        return true;
                    }
                }

                // Record new input
                for (auto btn : binding.buttons) {
                    if (controller_.get_digital_new_press(btn)) {
                        input_history_.emplace_back(now, std::to_string(static_cast<int>(btn)));
                        break;
                    }
                }
                return false;
            }
        }
        return false;
    }

public:
    InputMapper(const std::string& name, pros::Controller& controller) 
        : name_(name), controller_(controller) {}

    // ISubsystem interface implementation
    void initialize() override { enabled_ = true; }
    void update() override {
        if (!enabled_) return;
        
        for (const auto& [name, binding] : bindings_) {
            if (checkBinding(binding)) {
                if (auto it = actions_.find(name); it != actions_.end()) {
                    it->second();
                }
            }
        }
    }
    void disable() override { enabled_ = false; }
    bool isEnabled() const override { return enabled_; }
    const std::string& getName() const override { return name_; }

    void addBinding(const std::string& name, const InputBinding& binding, 
                   std::function<void()> action) {
        bindings_[name] = binding;
        actions_[name] = std::move(action);
    }

    void removeBinding(const std::string& name) {
        bindings_.erase(name);
        actions_.erase(name);
    }
};

// Macro system class
template<typename ChassisConfig>
class MacroSystem : public core::ISubsystem {
private:
    std::string name_;
    Chassis<ChassisConfig>& chassis_;
    std::unordered_map<std::string, std::unique_ptr<Macro>> macros_;
    std::string active_macro_;
    bool enabled_ = false;

public:
    MacroSystem(const std::string& name, Chassis<ChassisConfig>& chassis) 
        : name_(name), chassis_(chassis) {}

    // ISubsystem interface implementation
    void initialize() override { enabled_ = true; }
    void update() override {
        if (!enabled_ || active_macro_.empty()) return;
        
        if (auto it = macros_.find(active_macro_); it != macros_.end()) {
            it->second->execute();
            if (it->second->isComplete()) {
                stopMacro();
            }
        }
    }
    void disable() override { 
        enabled_ = false;
        stopMacro();
    }
    bool isEnabled() const override { return enabled_; }
    const std::string& getName() const override { return name_; }

    void registerMacro(const std::string& name, std::unique_ptr<Macro> macro) {
        macros_[name] = std::move(macro);
    }

    bool startMacro(const std::string& name) {
        if (!enabled_) return false;
        
        if (auto it = macros_.find(name); it != macros_.end() && active_macro_.empty()) {
            active_macro_ = name;
            it->second->reset();
            return true;
        }
        return false;
    }

    void stopMacro() {
        active_macro_.clear();
    }

    bool isMacroActive() const {
        return !active_macro_.empty();
    }

    Chassis<ChassisConfig>& getChassis() { return chassis_; }
};

// Movement macro implementation
class MovementMacro : public Macro {
private:
    std::function<void()> movement_func_;
    bool complete_ = false;

public:
    explicit MovementMacro(std::function<void()> func) 
        : movement_func_(std::move(func)) {}

    void execute() override {
        if (!complete_) {
            movement_func_();
            complete_ = true;
        }
    }

    bool isComplete() const override {
        return complete_;
    }

    void reset() override {
        complete_ = false;
    }
};

// Enhanced driver control
template<typename ChassisConfig>
class EnhancedDriverControl : public core::ISubsystem {
private:
    std::string name_;
    MacroSystem<ChassisConfig>& macro_system_;
    InputMapper<ChassisConfig>& input_mapper_;
    DriverConfig config_;
    bool enabled_ = false;

public:
    EnhancedDriverControl(const std::string& name,
                         MacroSystem<ChassisConfig>& macro_system,
                         InputMapper<ChassisConfig>& input_mapper,
                         const DriverConfig& config = DriverConfig())
        : name_(name)
        , macro_system_(macro_system)
        , input_mapper_(input_mapper)
        , config_(config) {}

    // ISubsystem interface implementation
    void initialize() override { enabled_ = true; }
    void update() override {
        if (!enabled_) return;
        
        if (macro_system_.isMacroActive()) {
            macro_system_.update();
        } else {
            input_mapper_.update();
        }
    }
    void disable() override { 
        enabled_ = false;
        macro_system_.disable();
    }
    bool isEnabled() const override { return enabled_; }
    const std::string& getName() const override { return name_; }
};

} // namespace movement
</file>

<file path="include/movement/driver_control.hpp">
#pragma once
#include "main.h"
#include "movement/chassis.hpp"
#include "pros/misc.hpp"
#include "core/subsystem.hpp"
#include <memory>

namespace movement {

// Driver control modes
enum class DriveMode {
    ARCADE,     // Single stick arcade
    SPLIT,      // Split arcade (drive/turn on separate sticks)
    TANK        // Traditional tank
};

// Driver control configuration
struct DriverConfig {
    DriveMode mode = DriveMode::ARCADE;
    double curve_factor = 1.5;      // Input curve for smoother control
    double deadzone = 0.05;         // Joystick deadzone
    double turn_scale = 0.8;        // Turn speed scaling
    int controller_id = 0;          // Primary = 0, Partner = 1
};

// Driver control class that works with our chassis
template<typename ChassisConfig>
class DriverControl : public core::ISubsystem {
private:
    std::string name_;
    Chassis<ChassisConfig>& chassis_;
    DriverConfig config_;
    pros::Controller controller_;
    bool enabled_ = false;

    // Input processing
    double applyDeadzone(double input) const {
        return std::abs(input) < config_.deadzone ? 0.0 : input;
    }

    double applyCurve(double input) const {
        return std::pow(std::abs(input), config_.curve_factor) * (input < 0 ? -1 : 1);
    }

    void processTankDrive() {
        if (!enabled_) return;
        
        double left = applyDeadzone(controller_.get_analog(ANALOG_LEFT_Y) / 127.0);
        double right = applyDeadzone(controller_.get_analog(ANALOG_RIGHT_Y) / 127.0);
        
        left = applyCurve(left);
        right = applyCurve(right);

        // Apply to left/right motor groups
        for (size_t i = 0; i < chassis_.getMotorCount(); i++) {
            bool is_left = i < chassis_.getMotorCount()/2;
            chassis_.setMotorVelocity(i, (is_left ? left : right) * 200.0);
        }
    }

    void processArcadeDrive(bool split) {
        if (!enabled_) return;

        double drive, turn;
        if (split) {
            drive = applyDeadzone(controller_.get_analog(ANALOG_LEFT_Y) / 127.0);
            turn = applyDeadzone(controller_.get_analog(ANALOG_RIGHT_X) / 127.0);
        } else {
            drive = applyDeadzone(controller_.get_analog(ANALOG_LEFT_Y) / 127.0);
            turn = applyDeadzone(controller_.get_analog(ANALOG_LEFT_X) / 127.0);
        }

        drive = applyCurve(drive);
        turn = applyCurve(turn) * config_.turn_scale;

        double left = drive + turn;
        double right = drive - turn;

        // Normalize if over ±1.0
        double max = std::max(std::abs(left), std::abs(right));
        if (max > 1.0) {
            left /= max;
            right /= max;
        }

        // Apply to motors
        for (size_t i = 0; i < chassis_.getMotorCount(); i++) {
            bool is_left = i < chassis_.getMotorCount()/2;
            chassis_.setMotorVelocity(i, (is_left ? left : right) * 200.0);
        }
    }

public:
    DriverControl(const std::string& name, Chassis<ChassisConfig>& chassis, 
                 const DriverConfig& config = DriverConfig())
        : name_(name)
        , chassis_(chassis)
        , config_(config)
        , controller_(config.controller_id == 0 ? 
              pros::Controller(pros::E_CONTROLLER_MASTER) 
            : pros::Controller(pros::E_CONTROLLER_PARTNER)) {}

    // ISubsystem interface implementation
    void initialize() override { enabled_ = true; }
    void update() override {
        if (!enabled_) return;
        
        switch (config_.mode) {
            case DriveMode::TANK:
                processTankDrive();
                break;
            case DriveMode::ARCADE:
                processArcadeDrive(false);
                break;
            case DriveMode::SPLIT:
                processArcadeDrive(true);
                break;
        }
    }
    
    void disable() override { 
        enabled_ = false;
        chassis_.stop();
    }
    
    bool isEnabled() const override { return enabled_; }
    const std::string& getName() const override { return name_; }

    // Configuration methods
    void setMode(DriveMode mode) { config_.mode = mode; }
    void setCurveFactor(double factor) { config_.curve_factor = factor; }
    void setDeadzone(double deadzone) { config_.deadzone = deadzone; }
    void setTurnScale(double scale) { config_.turn_scale = scale; }

    // Get current config
    const DriverConfig& getConfig() const { return config_; }
};

} // namespace movement
</file>

<file path="include/subsystems/clamp.hpp">
#pragma once
#include "main.h"
#include "pros/adi.hpp"
#include "core/subsystem.hpp"
#include <memory>

namespace subsystems {

// Clamp-specific configuration
struct ClampConfig : public core::SubsystemConfig {
    char port;
    bool default_state = false;
    
    ClampConfig(char port_num, bool dev = false) 
        : port(port_num) {
        dev_mode = dev;
    }
};

class Clamp : public core::Subsystem<ClampConfig> {
private:
    std::unique_ptr<pros::adi::DigitalOut> solenoid_;
    bool is_clamped_ = false;

    // Internal state change with event emission
    void setState(bool clamped) {
        if (is_clamped_ != clamped) {
            is_clamped_ = clamped;
            if (!config_.dev_mode && solenoid_) {
                solenoid_->set_value(is_clamped_);
            }
            // Emit state change event
            core::EventSystem::getInstance().emit("clamp_state_changed", is_clamped_);
        }
    }

public:
    Clamp(const std::string& name, const ClampConfig& config)
        : core::Subsystem<ClampConfig>(name, config) {}

    void initialize() override {
        if (!config_.dev_mode) {
            solenoid_ = std::make_unique<pros::adi::DigitalOut>(config_.port);
            setState(config_.default_state);
        }
        Subsystem::initialize();
    }

    void update() override {
        // Could add periodic checks or maintenance here
    }

    // Toggle clamp state
    void toggle() {
        setState(!is_clamped_);
    }

    // Directly set clamp state
    void setClamp(bool clamped) {
        setState(clamped);
    }

    // Get current state
    bool isClamped() const { return is_clamped_; }

    // Factory method for easy creation and registration
    static std::shared_ptr<Clamp> create(const std::string& name, char port, bool dev_mode = false) {
        ClampConfig config(port, dev_mode);
        auto clamp = std::make_shared<Clamp>(name, config);
        core::SubsystemRegistry::getInstance().registerSubsystem(clamp);
        return clamp;
    }
};

} // namespace subsystems
</file>

<file path="include/api.h">
/**
 * \file api.h
 *
 * PROS API header provides high-level user functionality
 *
 * Contains declarations for use by typical VEX programmers using PROS.
 *
 * This file should not be modified by users, since it gets replaced whenever
 * a kernel upgrade occurs.
 *
 * \copyright Copyright (c) 2017-2023, Purdue University ACM SIGBots.
 * All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

#ifndef _PROS_API_H_
#define _PROS_API_H_

#ifdef __cplusplus
#include <cerrno>
#include <cmath>
#include <cstdbool>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#else /* (not) __cplusplus */
#include <errno.h>
#include <math.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#endif /* __cplusplus */

#define PROS_VERSION_MAJOR 4
#define PROS_VERSION_MINOR 1
#define PROS_VERSION_PATCH 1
#define PROS_VERSION_STRING "4.1.1"


#include "pros/adi.h"
#include "pros/colors.h"
#include "pros/device.h"
#include "pros/distance.h"
#include "pros/error.h"
#include "pros/ext_adi.h"
#include "pros/gps.h"
#include "pros/imu.h"
#include "pros/link.h"
#include "pros/llemu.h"
#include "pros/misc.h"
#include "pros/motors.h"
#include "pros/optical.h"
#include "pros/rotation.h"
#include "pros/rtos.h"
#include "pros/screen.h"
#include "pros/vision.h"

#ifdef __cplusplus
#include "pros/adi.hpp"
#include "pros/colors.hpp"
#include "pros/device.hpp"
#include "pros/distance.hpp"
#include "pros/gps.hpp"
#include "pros/imu.hpp"
#include "pros/link.hpp"
#include "pros/llemu.hpp"
#include "pros/misc.hpp"
#include "pros/motor_group.hpp"
#include "pros/motors.hpp"
#include "pros/optical.hpp"
#include "pros/rotation.hpp"
#include "pros/rtos.hpp"
#include "pros/screen.hpp"
#include "pros/vision.hpp"
#endif

#endif  // _PROS_API_H_
</file>

<file path="include/main.h">
/**
 * \file main.h
 *
 * Contains common definitions and header files used throughout your PROS
 * project.
 *
 * \copyright Copyright (c) 2017-2023, Purdue University ACM SIGBots.
 * All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

#ifndef _PROS_MAIN_H_
#define _PROS_MAIN_H_

/**
 * If defined, some commonly used enums will have preprocessor macros which give
 * a shorter, more convenient naming pattern. If this isn't desired, simply
 * comment the following line out.
 *
 * For instance, E_CONTROLLER_MASTER has a shorter name: CONTROLLER_MASTER.
 * E_CONTROLLER_MASTER is pedantically correct within the PROS styleguide, but
 * not convenient for most student programmers.
 */
#define PROS_USE_SIMPLE_NAMES

/**
 * If defined, C++ literals will be available for use. All literals are in the
 * pros::literals namespace.
 *
 * For instance, you can do `4_mtr = 50` to set motor 4's target velocity to 50
 */
#define PROS_USE_LITERALS

#include "api.h"

/**
 * You should add more #includes here
 */
//#include "okapi/api.hpp"

/**
 * If you find doing pros::Motor() to be tedious and you'd prefer just to do
 * Motor, you can use the namespace with the following commented out line.
 *
 * IMPORTANT: Only the okapi or pros namespace may be used, not both
 * concurrently! The okapi namespace will export all symbols inside the pros
 * namespace.
 */
// using namespace pros;
// using namespace pros::literals;
// using namespace okapi;

/**
 * Prototypes for the competition control tasks are redefined here to ensure
 * that they can be called from user code (i.e. calling autonomous from a
 * button press in opcontrol() for testing purposes).
 */
#ifdef __cplusplus
extern "C" {
#endif
void autonomous(void);
void initialize(void);
void disabled(void);
void competition_initialize(void);
void opcontrol(void);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
/**
 * You can add C++-only headers here
 */
//#include <iostream>
#endif

#endif  // _PROS_MAIN_H_
</file>

<file path="include/robot_state.hpp">
#pragma once
#include "main.h"
#include "core/subsystem.hpp"
#include "movement/chassis.hpp"
#include "movement/control_system.hpp"
#include "movement/driver_control.hpp"
#include "subsystems/clamp.hpp"
#include <memory>

// Global configuration for the robot
struct RobotConfig {
    bool dev_mode = false;
    struct {
        std::vector<int> left_motor_ports;
        std::vector<int> right_motor_ports;
        int imu_port;
    } chassis;
    struct {
        char port;
    } clamp;
    struct {
        movement::DriveMode mode = movement::DriveMode::SPLIT;
    } driver;
};

class RobotState {
private:
    // Define chassis configuration type
    struct MainChassisConfig : movement::ChassisConfig<movement::DriveType::TANK, movement::OdomType::IMU_ENHANCED> {
        // Add any custom chassis configuration here if needed
    };
    
    RobotConfig config_;
    pros::Controller master_{pros::E_CONTROLLER_MASTER};
    
    // Singleton instance
    static std::unique_ptr<RobotState> instance_;

    // Private constructor for singleton
    explicit RobotState(const RobotConfig& config) : config_(config) {
        initializeSubsystems();
    }

    void initializeSubsystems() {
        auto& registry = core::SubsystemRegistry::getInstance();

        // Initialize chassis
        auto chassis = std::make_shared<movement::Chassis<MainChassisConfig>>("main_chassis");
        
        // Configure motors
        for (int port : config_.chassis.left_motor_ports) {
            chassis->addMotor(port);
        }
        for (int port : config_.chassis.right_motor_ports) {
            chassis->addMotor(port, true);  // Right side reversed
        }

        if (!config_.dev_mode) {
            chassis->initializeSensors(config_.chassis.imu_port);
        }

        registry.registerSubsystem(chassis);

        // Initialize clamp subsystem
        auto clamp = subsystems::Clamp::create("main_clamp", config_.clamp.port, config_.dev_mode);

        // Initialize control systems
        auto driver = std::make_shared<movement::DriverControl<MainChassisConfig>>(
            "main_driver",
            *chassis,
            movement::DriverConfig{.mode = config_.driver.mode}
        );
        registry.registerSubsystem(driver);

        // Initialize input mapper and macro system
        auto input_mapper = std::make_shared<movement::InputMapper<MainChassisConfig>>(
            "main_input_mapper",
            master_
        );
        registry.registerSubsystem(input_mapper);

        auto macro_system = std::make_shared<movement::MacroSystem<MainChassisConfig>>(
            "main_macro",
            *chassis
        );
        registry.registerSubsystem(macro_system);

        // Initialize enhanced driver control
        auto enhanced_driver = std::make_shared<movement::EnhancedDriverControl<MainChassisConfig>>(
            "main_enhanced_driver",
            *macro_system,
            *input_mapper,
            movement::DriverConfig{.mode = config_.driver.mode}
        );
        registry.registerSubsystem(enhanced_driver);

        setupControls(input_mapper, clamp);
    }

    void setupControls(
        const std::shared_ptr<movement::InputMapper<MainChassisConfig>>& input_mapper,
        const std::shared_ptr<subsystems::Clamp>& clamp
    ) {
        if (input_mapper && clamp) {
            // Configure clamp control binding
            movement::InputBinding clamp_binding{
                .type = movement::InputType::BUTTON,
                .buttons = {pros::E_CONTROLLER_DIGITAL_R1}
            };
            input_mapper->addBinding("toggle_clamp", clamp_binding, 
                [clamp]() { clamp->toggle(); });
        }

        // Subscribe to clamp state changes for potential feedback
        core::EventSystem::getInstance().subscribe<bool>("clamp_state_changed",
            [this](const bool& is_clamped) {
                // Could add controller rumble or other feedback here
            });
    }

public:
    // Singleton access with configuration
    static RobotState& getInstance(const RobotConfig& config = RobotConfig()) {
        if (!instance_) {
            instance_ = std::unique_ptr<RobotState>(new RobotState(config));
        }
        return *instance_;
    }

    // Delete copy/move operations
    RobotState(const RobotState&) = delete;
    RobotState& operator=(const RobotState&) = delete;
    RobotState(RobotState&&) = delete;
    RobotState& operator=(RobotState&&) = delete;

    // Main update loop
    void update() {
        auto& registry = core::SubsystemRegistry::getInstance();
        registry.updateAll();
    }

    // Reset robot state
    void reset() {
        auto& registry = core::SubsystemRegistry::getInstance();
        
        if (!config_.dev_mode) {
            if (auto chassis = registry.getSubsystemByType<movement::Chassis<MainChassisConfig>>()) {
                chassis->initializeSensors(config_.chassis.imu_port);
            }
        }

        if (auto clamp = registry.getSubsystem<subsystems::Clamp>("main_clamp")) {
            clamp->setClamp(false);
        }
    }

    // Access subsystems through the registry
    template<typename T>
    std::shared_ptr<T> getSubsystem(const std::string& name) {
        return core::SubsystemRegistry::getInstance().getSubsystem<T>(name);
    }

    template<typename T>
    std::shared_ptr<T> getSubsystemByType() {
        return core::SubsystemRegistry::getInstance().getSubsystemByType<T>();
    }

    // Getter for clamp subsystem specifically
    subsystems::Clamp& getClamp() {
        if (auto clamp = getSubsystem<subsystems::Clamp>("main_clamp")) {
            return *clamp;
        }
        throw std::runtime_error("Clamp subsystem not initialized");
    }

    // Getter for chassis subsystem specifically
    movement::Chassis<MainChassisConfig>& getChassis() {
        if (auto chassis = getSubsystemByType<movement::Chassis<MainChassisConfig>>()) {
            return *chassis;
        }
        throw std::runtime_error("Chassis subsystem not initialized");
    }

    bool isDevMode() const { return config_.dev_mode; }
};

// Initialize static member
std::unique_ptr<RobotState> RobotState::instance_;
</file>

<file path="src/control_system_impl.cpp">
#include "movement/control_system.hpp"
#include "movement/chassis.hpp"
#include "movement/driver_control.hpp"

namespace movement {

// Example helper function to setup a complete control system
template<typename ChassisConfig>
std::unique_ptr<EnhancedDriverControl<ChassisConfig>> setupControlSystem(
    const std::string& name,
    Chassis<ChassisConfig>& chassis,
    pros::Controller& controller
) {
    // Create macro system
    auto macro_system = std::make_unique<MacroSystem<ChassisConfig>>(
        name + "_macro",
        chassis
    );
    
    // Create input mapper
    auto input_mapper = std::make_unique<InputMapper<ChassisConfig>>(
        name + "_input",
        controller
    );

    // Register example macros
    
    // Quick turn 180 degrees macro
    macro_system->registerMacro("turn_180", std::make_unique<MovementMacro>([&chassis]() {
        chassis.turnTo(M_PI);
    }));

    // Drive square pattern macro
    macro_system->registerMacro("square_pattern", std::make_unique<MovementMacro>([&chassis]() {
        for (int i = 0; i < 4; i++) {
            chassis.moveTo(field::Point{24.0, 0.0});
            chassis.turnTo(M_PI/2);
        }
    }));

    // Setup input bindings
    
    // Button combo for 180-degree turn
    InputBinding turn_180_binding{
        .type = InputType::BUTTON_COMBO,
        .buttons = {DIGITAL_L1, DIGITAL_R1}
    };
    input_mapper->addBinding("turn_180", turn_180_binding, [&macro_system]() {
        macro_system->startMacro("turn_180");
    });

    // Button sequence for square pattern
    InputBinding square_pattern_binding{
        .type = InputType::SEQUENCE,
        .buttons = {DIGITAL_UP, DIGITAL_UP, DIGITAL_DOWN},
        .sequence_window = std::chrono::milliseconds(1000)
    };
    input_mapper->addBinding("square_pattern", square_pattern_binding, [&macro_system]() {
        macro_system->startMacro("square_pattern");
    });

    // Custom drive controls
    InputBinding forward_binding{
        .type = InputType::ANALOG_ABOVE,
        .analog = ANALOG_LEFT_Y,
        .threshold = 0.1
    };
    input_mapper->addBinding("drive_forward", forward_binding, [&chassis]() {
        for (size_t i = 0; i < chassis.getMotorCount(); i++) {
            chassis.setMotorVelocity(i, 200.0);
        }
    });

    // Create and return enhanced driver control
    return std::make_unique<EnhancedDriverControl<ChassisConfig>>(
        name,
        *macro_system,
        *input_mapper
    );
}

// Example function to run an autonomous routine
template<typename ChassisConfig>
void runAutonomousRoutine(MacroSystem<ChassisConfig>& macro_system) {
    macro_system.startMacro("turn_180");
    while (macro_system.isMacroActive()) {
        macro_system.update();
        pros::delay(10);
    }

    macro_system.startMacro("square_pattern");
    while (macro_system.isMacroActive()) {
        macro_system.update();
        pros::delay(10);
    }
}

} // namespace movement
</file>

<file path="src/main.cpp">
#include "main.h"
#include "robot_state.hpp"
#include "constants/fieldConstants.hpp"

void initialize() {
    // Configure the robot
    RobotConfig config;
    
    // Configure chassis
    config.chassis.left_motor_ports = {1, 2};     // Left front and back
    config.chassis.right_motor_ports = {3, 4};    // Right front and back
    config.chassis.imu_port = 5;                  // IMU port
    
    // Configure subsystems
    config.clamp.port = 'A';                      // Pneumatic clamp port
    
    // Configure driver controls
    config.driver.mode = movement::DriveMode::SPLIT;  // Split arcade drive
    
    // Initialize robot with configuration
    RobotState::getInstance(config);
}

void disabled() {
    core::SubsystemRegistry::getInstance().disableAll();
}

void competition_initialize() {}

void autonomous() {
    auto& robot = RobotState::getInstance();
    
    using ChassisConfig = movement::ChassisConfig<movement::DriveType::TANK, movement::OdomType::IMU_ENHANCED>;
    
    if (auto macro_system = robot.getSubsystemByType<movement::MacroSystem<ChassisConfig>>()) {
        // Create and register autonomous macro
        auto auton_macro = std::make_unique<movement::MovementMacro>([&robot]() {
            if (auto chassis = robot.getSubsystemByType<movement::Chassis<ChassisConfig>>()) {
                // Move forward
                for (size_t i = 0; i < chassis->getMotorCount(); i++) {
                    chassis->setMotorVelocity(i, 100); // 50% speed forward
                }
                pros::delay(1000);
                chassis->stop();
                
                // Move to specific point
                field::Point target_point(24, 0);
                chassis->moveTo(target_point);
            }
            
            if (auto clamp = robot.getSubsystem<subsystems::Clamp>("main_clamp")) {
                clamp->toggle();
            }
        });
        
        macro_system->registerMacro("auton_routine", std::move(auton_macro));
        macro_system->startMacro("auton_routine");
        
        // Run autonomous loop
        while (pros::competition::is_autonomous()) {
            robot.update();
            pros::delay(10);
        }
    }
}

void opcontrol() {
    auto& robot = RobotState::getInstance();
    
    // Main control loop
    while (true) {
        robot.update();
        pros::delay(10);
    }
}
</file>

<file path="src/movement_impl.cpp">
#include "movement/chassis.hpp"
#include "movement/driver_control.hpp"
#include <memory>

// Robot configuration and control systems
namespace robot {

// Define the chassis type we want to use
using ChassisType = movement::Chassis<movement::ChassisConfig<
    movement::DriveType::TANK,
    movement::OdomType::IMU_ENHANCED
>>;

// Global instances
std::unique_ptr<ChassisType> chassis;
std::unique_ptr<movement::DriverControl<movement::ChassisConfig<
    movement::DriveType::TANK,
    movement::OdomType::IMU_ENHANCED
>>> driver;

void initializeChassis() {
    // Create chassis instance
    chassis = std::make_unique<ChassisType>();
    
    // Add drive motors (port numbers are examples)
    chassis->addMotor(1, false);  // Left front
    chassis->addMotor(2, false);  // Left back
    chassis->addMotor(3, true);   // Right front
    chassis->addMotor(4, true);   // Right back
    
    // Initialize sensors
    chassis->initializeSensors(10); // IMU on port 10

    // Create driver control with custom configuration
    movement::DriverConfig driver_config;
    driver_config.mode = movement::DriveMode::SPLIT; // Split arcade drive
    driver_config.curve_factor = 1.8;  // More aggressive curve for finer control
    driver_config.turn_scale = 0.7;    // Reduce turning speed
    
    driver = std::make_unique<movement::DriverControl<movement::ChassisConfig<
        movement::DriveType::TANK,
        movement::OdomType::IMU_ENHANCED
    >>>(*chassis, driver_config);
}

// Autonomous movement functions
void moveToGoal() {
    // Move to the center mobile goal
    chassis->moveTo(field::mobile_goals::CENTER.position);
    
    // Turn to face the high stake
    double angle = chassis->getPosition().angleTo(field::ladder::HIGH_STAKE.position);
    chassis->turnTo(angle);
}

// Driver control update function - call this in opcontrol loop
void updateDriverControl() {
    if (driver) {
        driver->update();
    }
}

// Example autonomous routine
void runAutonomous() {
    // Move to center goal
    chassis->moveTo(field::mobile_goals::CENTER.position);
    
    // Turn to face alliance goal
    chassis->turnTo(0); // Assuming 0 is facing alliance side
    
    // Move to another position
    chassis->moveTo(field::mobile_goals::BOTTOM_LEFT.position);
}

// Example operator control
void runOpControl() {
    while (true) {
        updateDriverControl();
        pros::delay(10); // Don't hog CPU
    }
}

} // namespace robot
</file>

<file path=".gitignore">
# Compiled Object files
*.o
*.obj

# Executables
*.bin
*.elf

# PROS
bin/
.vscode/
.cache/
compile_commands.json
temp.log
temp.errors
*.ini
.d/
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
include/liblvgl
include/pros
project.pros
common.mk
firmware
</file>

<file path="Makefile">
################################################################################
######################### User configurable parameters #########################
# filename extensions
CEXTS:=c
ASMEXTS:=s S
CXXEXTS:=cpp c++ cc

# probably shouldn't modify these, but you may need them below
ROOT=.
FWDIR:=$(ROOT)/firmware
BINDIR=$(ROOT)/bin
SRCDIR=$(ROOT)/src
INCDIR=$(ROOT)/include

WARNFLAGS+=
EXTRA_CFLAGS=
EXTRA_CXXFLAGS=

# Set to 1 to enable hot/cold linking
USE_PACKAGE:=1

# Add libraries you do not wish to include in the cold image here
# EXCLUDE_COLD_LIBRARIES:= $(FWDIR)/your_library.a
EXCLUDE_COLD_LIBRARIES:= 

# Set this to 1 to add additional rules to compile your project as a PROS library template
IS_LIBRARY:=0
# TODO: CHANGE THIS! 
# Be sure that your header files are in the include directory inside of a folder with the
# same name as what you set LIBNAME to below.
LIBNAME:=libbest
VERSION:=1.0.0
# EXCLUDE_SRC_FROM_LIB= $(SRCDIR)/unpublishedfile.c
# this line excludes opcontrol.c and similar files
EXCLUDE_SRC_FROM_LIB+=$(foreach file, $(SRCDIR)/main,$(foreach cext,$(CEXTS),$(file).$(cext)) $(foreach cxxext,$(CXXEXTS),$(file).$(cxxext)))

# files that get distributed to every user (beyond your source archive) - add
# whatever files you want here. This line is configured to add all header files
# that are in the directory include/LIBNAME
TEMPLATE_FILES=$(INCDIR)/$(LIBNAME)/*.h $(INCDIR)/$(LIBNAME)/*.hpp

.DEFAULT_GOAL=quick

################################################################################
################################################################################
########## Nothing below this line should be edited by typical users ###########
-include ./common.mk
</file>

<file path="repomix.config.json">
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  }
}
</file>

</repository_files>
